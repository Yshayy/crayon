<html>
<head>
	<link rel="stylesheet" type="text/css" href="../../crayon.css" media="screen" />
	<script type="text/javascript" src="../../jquery-1.3.2.min.js"></script>	
	<script type="text/javascript" src="../../client-graphing.js"></script>
	<script type="text/javascript" src="../../client-querying.js"></script>
	<script type="text/javascript" src="../../dygraph-combined.js"></script> 
<!--	<script type="text/javascript" src="/socket.io/socket.io.js"></script>-->
	

	<style TYPE="text/css">
	
	.serverCol {	
		margin: 0px; 
		padding: 0px; 
		vertical-align:top;
		text-align:center;
	}

	</style>
</head>
<body>
<div id="pageBody" class="frameBody">
<h1 style="margin-top: 80;">Last half hour values per 10 seconds</h1>
<table id="pageTable" cellSpacing="5" cellpadding="0" style="margin: 20px"></table>
</div>

</body>
<script type="text/javascript" src="../../crayon-ui.js"></script>
<script type="text/javascript">

var pageHeader = "System Status"
var invisibleDivEl;
var graphCols = 1;
var graphWidth = 600;
var graphHeight = 50;
var seriesByName = {};
//if (queryArgs.server) pageHeader += " > " + queryArgs.server;
setHeader(pageHeader);

var graphs = {
	"addAPIms": { title: "Mongo Write ms", series: ["Upsert ms to samples_sec"], extraOptions: { stackedGraph: true, "lineStyles": [{"match": ".*","aggregative": "max"}] } },
	"mWrites": { title: "Mongo Inserts", series: ["Inserts"], extraOptions: { stackedGraph: true, "lineStyles": [{"match": ".*","aggregative": "max"}] } },
	"mEtagCol": { title: "ETAG Collisions", series: ["Etag Collisions"], "lineStyles": [{"match": ".*","aggregative": "max"}] },
	"mErrLogged": { title: "Errors Logged", series: ["Errors Logged"], "lineStyles": [{"match": ".*","aggregative": "max"}] }
}

var extraOptionsAlsoForGraphDesigner = {
	errorBars: false,
	fillGraph: true,
	wholeWindow: 1
}

var plotGraph = function(allGraphData) {
	 

	var pageTable = $("#pageTable");

	var seriesLinesByName = {}
	for (var seriesIndex in allGraphData) {
		var series = allGraphData[seriesIndex];
		var seriesLines = seriesLinesByName[series.n];
		if (!seriesLines) {
			seriesLinesByName[series.n] = seriesLines = [];
		}
		seriesLines.push(series);
	}


	var graphsInLastRow = 0;
	for (graphId in graphs) {
		var graph = graphs[graphId];

		var extraOptions  = {
			drawXAxis: false,
			drawXGrid: false,
			showRangeSelector: false,
			legend: "never",
			highlightCircleSize: 0,
			highlightSeriesOpts: null,
			highlightSeriesBackgroundAlpha: 1,
			axisLabelFontSize: 10,
			axisLabelWidth: 3,
			axisLineWidth: 2,
			pixelsPerLabel: 13,
			yValuePadRatio: 1.3,
			
			yAxisLabelWidth: 30,
			axes: { 
				y: { 
					pixelsPerLabel: 15, 
					//axisLabelFormatter: function(y) { return (y?y:""); }
				} 
			}
		}

		for (extraOption in extraOptionsAlsoForGraphDesigner) {
			extraOptions[extraOption] = extraOptionsAlsoForGraphDesigner[extraOption];
		}
		for (extraOption in graph.extraOptions) {
			extraOptions[extraOption] = graph.extraOptions[extraOption];
		}



		// Add new row if required
		if (graphsInLastRow++ % graphCols == 0) {
			pageTable.append('<tr id="row_' + graphId + '"></tr>');
			lastRow = $("#row_" + graphId);
		}
		
		lastRow.append('<td><div class="minigraphLeftTitle" id="title_' + graphId + '" style="width:150px">' + graph.title + '</div></td>');
		lastRow.append('<td><div class="minigraph" onclick="minigraphClicked(this)" id="graph_' + graphId + '" style="width:' + graphWidth + '; height:' + graphHeight + '"></div></td>');
		var graphDivJQ = $("#graph_" + graphId);
		var graphDiv = graphDivJQ.get()[0];
		
		var graphData = [];
		for (nameIndex in graph.series) {
			var seriesName = graph.series[nameIndex];
			var lines = seriesLinesByName[seriesName];
			if (lines != null && lines.length > 0) {
				graphData = graphData.concat(lines);
			}
		}
	
		if (graphData.length == 0) {
			console.warn("No data found for graph " + graph.title);
		} else {
			drawGraph(graphDiv, invisibleDivEl, graphData, extraOptions);
		}
		graphDivJQ.width(graphDivJQ.width()-5);
		
	}

	hideOverlay();
}

var updateGraph = function(updatedData) {
	var seriesLinesByName = {}

	for (var seriesIndex in updatedData) {
		var series = updatedData[seriesIndex];
		if (series == null) {
			debugger;
		}
		var seriesLines = seriesLinesByName[series.n];
		if (!seriesLines) {
			seriesLinesByName[series.n] = seriesLines = [];
		}
		seriesLines.push(series);
	}

	for (graphId in graphs) {
		var graph = graphs[graphId];

		var graphData = [];
		for (nameIndex in graph.series) {
			var seriesName = graph.series[nameIndex];
			var lines = seriesLinesByName[seriesName];
			if (lines != null && lines.length > 0) {
				graphData = graphData.concat(lines);
			}
		}

		var graphDivJQ = $("#graph_" + graphId);
		var graphDiv = graphDivJQ.get()[0];

		updateDrawnGraph(graphDiv, graphData);
	}
}


var minigraphClicked = function(el) {
	
	// The ID contains the name
	var elId = $(el).attr("id");

	var extraOptions = extraOptionsAlsoForGraphDesigner;

	// Removing the prefix graph_
	var graphId = elId;
	if (graphId.indexOf("graph_") == 0) graphId = graphId.substring(6);
	var graph = graphs[graphId];

	// Preparing arguments to build query line
	var now = new Date();
	var startFrom = now.addHours(-6);
	
	for (extraOption in graph.extraOptions) {
		extraOptions[extraOption] = graph.extraOptions[extraOption];
	}

	var queryLine = 
		"?from=last 30 minutes" + 
		"&unit=s" + 
		"&names=" + encodeURIComponent(JSON.stringify(graph.series)) + 
		"&graphOpts=" + encodeURIComponent(JSON.stringify(extraOptions));

	window.location.href = "/designer.html" + queryLine;
}

var loadSystemDashboard = function() {
	var now = new Date();
	var startFrom = now.addMinutes(-30);
	$(pageBody).append("<div id='invisibleDiv' style='display: none; position:fixed; z-index:-1; width:0px, height:0px'></div>");
	invisibleDivEl = $("#invisibleDiv").get()[0];

	showLoadingGraphDataOverlay();
	new Query({
		dateFrom: startFrom, 
		dateTo: null,
		unit: 's',
		hosts: null, // Don't filter servers
		components: 'crayon%', // Don't filter components
		names: null, // Don't filter names
		fields: onlyFieldsRequiredForPlot, // projections, field to select
		callback: plotGraph,
		tailSecondsInterval: 10,
		tailCallback: updateGraph
	}).queryData();
}

/*
var socket = io.connect('prod2-t1.taboolasyndication.com');
socket.on('browserSocket', function (data) {
	console.log(data);
	socket.emit('serverSocket', { my: 'data' });
});
*/

loadSystemDashboard();
</script>
</html>