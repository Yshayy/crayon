<!doctype html>
<html>
<head>
	<script type="text/javascript" src="../../jquery-1.3.2.min.js"></script>	
	<script type="text/javascript" src="../../client-graphing.js"></script>
	<script type="text/javascript" src="../../client-querying.js"></script>
	<script type="text/javascript" src="../../dygraph-combined.js"></script> 
	<script type="text/javascript" src="/forecasting/nostradamus-combined.js"></script> 
</head>
<body>
<div id="pageBody" class="frameBody">
<div id="pageTable" style="margin: 20px;">
</div>
</div>
<div id='invisibleDiv' style='display: none; position:fixed; z-index:-1; width:0px, height:0px'></div>
<div id='highlightSeriesLabelDiv' style='display: none; position:fixed; z-index:-1; width:0px, height:0px'></div>
</body>
<script type="text/javascript" src="../../crayon-ui.js"></script>
<script type="text/javascript">

var graphCols = 1;
var graphWidth = 600;
var graphHeight = 50;
var seriesByName = {};

var dashboard = {
}

var aggregativeFunctions = {
	max: function(prevValue,newValue) { return (prevValue < newValue ? newValue : prevValue); },
	min: function(prevValue,newValue) { return (prevValue > newValue ? newValue : prevValue); },
	sum: function(prevValue,newValue) { return (prevValue + newValue); },
	ave: function(prevValue,newValue,prevCount) { return (((prevCount*prevValue) + newValue) / (prevCount + 1)); }
};

var plotGraph = function(allGraphData, graph) {
	try {

		var pageTable = $("#pageTable");
		
		var graphDataChanged = false;

		var totalMatches = 0;
		var totalMismatches = 0;
		if (graph.calculatedDataSources && graph.calculatedDataSources.length > 0) {
			for (cdsIndex in graph.calculatedDataSources) {
				var cds = graph.calculatedDataSources[cdsIndex];
				
				// Check if it is a reference to a common calculated datasource
				if (typeof cds == "string") {
					if (dashboard && dashboard.calculatedDataSources) {
						for (commonCdsIndex in dashboard.calculatedDataSources) {
							var commonCds = dashboard.calculatedDataSources[commonCdsIndex];
							if (commonCds.name == cds) {
								cds = commonCds;
							}
						}
					}
				}

				if (!cds.function) {
					console.error("Missing function attribute on calculatedDataSource: " + JSON.stringify(cds));
					continue;
				}

				if (!cds.match) {
					console.error("Missing match attribute on calculatedDataSource: " + JSON.stringify(cds));
					continue;
				}

				var func = aggregativeFunctions[cds.function];
				if (func == null) {
					console.error("Unknown function attribute on calculatedDataSource: " + JSON.stringify(cds));
					continue;
				}

				var byTime = {};
				for (var dataPointIndex in allGraphData) {
					var dataPoint = allGraphData[dataPointIndex];
					var matchObj = cds.match;
					var isMatch = false;
					for (k in cds.match) {
						var minifiedK = k;
						if (k == "name") minifiedK = "n";
						if (k == "server") minifiedK = "s";
						if (k == "component") minifiedK = "c";

						isMatch = dataPoint[minifiedK] && dataPoint[minifiedK].toString().match(cds.match[k])
						if (isMatch) break;
					}

					if (isMatch) {
						totalMatches++;
						var aggregatedPoint = byTime[dataPoint.t]
						if (!aggregatedPoint) {
							aggregatedPoint = {};
							for (k in dataPoint) aggregatedPoint[k] = dataPoint[k];
							aggregatedPoint.N = aggregatedPoint.N || 1;
							aggregatedPoint.n = cds.name||JSON.stringify(cds);
							aggregatedPoint.c = null;
							aggregatedPoint.s = null;
							aggregatedPoint.isAggregated = true;
							allGraphData.push(aggregatedPoint);
							graphDataChanged = true;
							byTime[dataPoint.t] = aggregatedPoint;
						} else {
							aggregatedPoint.A = func(aggregatedPoint.A, dataPoint.A, aggregatedPoint.N);
							aggregatedPoint.S = func(aggregatedPoint.S, dataPoint.S, aggregatedPoint.N);
							aggregatedPoint.M = func(aggregatedPoint.M, dataPoint.M, aggregatedPoint.N);
							aggregatedPoint.m = func(aggregatedPoint.m, dataPoint.m, aggregatedPoint.N);
							aggregatedPoint.N += 1;
						}

						if (cds.insteadOfMatches) dataPoint.remove = true;
					} else {
						totalMismatches++;
					}
				}
			}
		}

		var graphData = []
		if (graphDataChanged) {
			for (i in allGraphData) {
				if (!allGraphData[i].remove) {
					graphData.push(allGraphData[i]);
				}
			} 
		} else {
			graphData = allGraphData;
		}

		if (cacheByDiv[graph.div.id]) {
			updateDrawnGraph(graph.div, graphData);
		} else if (graphData.length == 0) {
			console.warn("No data found for graph " + graph.dyGraphTitle);
			graph.overlayText.html("No Data");
		} else {
			drawGraph(graph.div, graph.legendDiv, graphData, graph.graphOpts);
			hideGraphOverlay(graph);
		}

	} catch (ex) {
		console.log(ex);
		graph.overlayText.html("Exception: " + ex.stack);
	}
}

var hideGraphOverlay = function(graphToQuery) {
	$(graphToQuery.overlay).css("opacity","0");
	setTimeout(function() {
		$(graphToQuery.overlay).css("display","none");
	},200);
}

var hideGraph = function(gDiv) {
	$(gDiv).css("display", "none")
}


function graphClicked(el) {
	var graphCodeObj = getGraphCode(el.graph);
	if (!graphCodeObj.graphs[0].graphOpts) graphCodeObj.graphs[0].graphOpts = {};
	graphCodeObj.graphs[0].graphOpts.width = "wholeLine";
	graphCodeObj.graphs[0].graphOpts.height = "600";

	var query = "?dashboard=" + encodeURIComponent(JSON.stringify(graphCodeObj));
  	var win=window.open(window.location.origin + "/by-json.html" + query, '_blank');

  	win.focus();
}

var ignoredGraphKeys = {};
ignoredGraphKeys["div"] = true;
ignoredGraphKeys["graphAndLegendDivString"] = true;
ignoredGraphKeys["graphDivString"] = true;
ignoredGraphKeys["graphOpts"] = true;
ignoredGraphKeys["legendDiv"] = true;
ignoredGraphKeys["legendDivString"] = true;
ignoredGraphKeys["dyGraphTitle"] = true;
ignoredGraphKeys["overlay"] = true;
ignoredGraphKeys["overlayText"] = true;
ignoredGraphKeys["query"] = true;

function getGraphCode(graph) {
	var dashboardCopy = JSON.parse(originalDashboardStr);
	dashboardCopy.graphs = dashboardCopy.graphs.splice(graph.index,1)
	//for (var i = dashboardCopy.graphs.length - 1; i>=0; --i) {
		
	//}

	var g = dashboardCopy.graphs[0];
	if (dashboardCopy.dataSources) {
		for (var i = dashboardCopy.dataSources.length - 1; i >=0; --i) {
			var id = dashboardCopy.dataSources[i].id;

			if (!id || !g.dataSources || g.dataSources.indexOf(id) == -1) {
				dashboardCopy.dataSources.splice(i,1);
			}
		} 
	}

	return dashboardCopy;
}

var codeGraph = function(el) {
	var graphCodeObj = getGraphCode(el.graph);

	var query = "?dashboard=" + encodeURIComponent(JSON.stringify(graphCodeObj));
  	var win=window.open(window.location.origin + "/designer.html" + query, '_blank');

  	win.focus();
}


var exportCSV = function(el) {
	var divCache = cacheByDiv[el.id];
	var sb = "time";
	for (seriesIndex in divCache.seriesArr) {
		sb += "," + divCache.seriesArr[seriesIndex].fullCounterName;
	}
	sb +="<br>"
	
	for (timeIndex in divCache.timeSlotArr) {
		var timeSlot = divCache.timeSlotArr[timeIndex];
		var row = [];

		sb += timeSlot[0].toLocaleString();
		for (var i = 1; i < timeSlot.length; ++i) {
			sb += "," + timeSlot[i];
		}
		sb +="<br>"
	}

	//var query = "?dashboard=" + encodeURIComponent(JSON.stringify(graphCodeObj));
  	var win=window.open();
  	$(win.document.body).html(sb);
  	win.focus();
}

var refreshGraph = function(gDiv) {
	var graph = gDiv.graph;
	graph.query.queryData();
}

var defaultHeight = 250;
var loadDashboard = function() {
	//$(pageBody).append("<div id='invisibleDiv' style='display: none; position:fixed; z-index:-1; width:0px, height:0px'></div>");
	//invisibleDivEl = $("#invisibleDiv").get()[0];

	var pageTable = $('#pageTable');
	var pageBody = $('#pageBody');
	lastCell = pageTable;
	//pageTable.append('<tr id="graphs_row"><td id="graphs_cell"></td></tr>');
	//var lastRow = $("#graphs_row");
	//var lastCell = $("#graphs_cell");

	setHeader(dashboard.header || "Untitled (Add 'header' at the root of your dashboard JSON)");

	//showLoadingGraphDataOverlay()
	for (graphNum in dashboard.graphs) {
		var graph = dashboard.graphs[graphNum];

		for (key in dashboard.defaultGraphOpts) {
			if (!graph.graphOpts) graph.graphOpts = {};
			if (graph.graphOpts[key] == null) graph.graphOpts[key] = dashboard.defaultGraphOpts[key];
		}

		// We're not going to query the entire database
		if (!graph.dataSources || graph.dataSources.length == 0) {
			console.error("Skipping graph because it contains no dataSources attribute with things to query");
			return;	
		}

		for (opt in dashboard.defaultDataSourceOpts) {
			for (dsIdx in dashboard.dataSources) {
				if (dashboard.dataSources[dsIdx][opt] == null)
					dashboard.dataSources[dsIdx][opt] = dashboard.defaultDataSourceOpts[opt];
			}
			for (dsIdx in graph.dataSources) {
				if (graph.dataSources[dsIdx][opt] == null)
					graph.dataSources[dsIdx][opt] = dashboard.defaultDataSourceOpts[opt];
			}
		}

		// Title
		var title = graph.graphOpts.title || "Untitled (Add 'title' under graphOpts)";
		var graphWidth = graph.graphOpts.width || 500;
		var graphHeight = graph.graphOpts.height || defaultHeight;
	    graph.graphOpts.legendWidth = graph.graphOpts.legendWidth || 230;
	    if (graph.graphOpts.noLegend) graph.graphOpts.legendWidth = 0;

	    var graphHtmlToAdd = '';
		graph.graphDivString = 'graph_' + graphNum;
		graph.legendDivString = 'legend_' + graphNum;
		graph.graphAndLegendDivString = 'grpah_and_legend_' + graphNum;
		
		var graphAndLegendStyle= "";
		if (graph.graphOpts.width == "wholeLine") {
			graphAndLegendStyle += "display:block;";
			graphWidth = getWholeLineWidth(graph);
		}

		graphHtmlToAdd += '<div id="grpah_and_legend_' + graphNum + '" class="graphAndLegendDiv" style="' + graphAndLegendStyle + '">'

		// Graph Options Bar
		graphHtmlToAdd += '<div class="graphOptionsBar" >';
		graphHtmlToAdd += '<span class="graphTitleSpan" onclick="graphClicked('+graph.graphDivString+')">' + title + '</span>';
		//graphHtmlToAdd += '<span class="crayonButton" onclick="hideGraph('+graph.graphAndLegendDivString+')" style="float:right;margin-right:10px">Hide</span>';
		//graphHtmlToAdd += '<span class="crayonButton" onclick="codeGraph('+graph.graphDivString+')" style="float:right;margin-right:5px">Code</span>';
		//graphHtmlToAdd += '<span class="crayonButton" onclick="refreshGraph('+graph.graphDivString+')" style="float:right;margin-right:5px">Refresh</span>';
		graphHtmlToAdd += '<span id="menuButton_' + graph.graphDivString + '" onclick="showOptionsForGraph('+
			graph.graphDivString+')" class="crayonButton" style="float:right;margin-right:10px">Options</span>';
		
		graphHtmlToAdd += '</div>';
		graphHtmlToAdd += '<div id="graphOverlay_' + graphNum + '" class="graphOverlay" style="width:' + (graphWidth + graph.graphOpts.legendWidth) + 'px; height:' + (graphHeight - 5) + 'px">';
		graphHtmlToAdd += '<span id="graphOverlayText_' + graphNum + '" class="graphOverlayText">Loading</span>';
		graphHtmlToAdd += '</div>';

		// Graph and legend
		graphHtmlToAdd += '<div id="graph_' + graphNum + '" class="graphDiv" style="width:' + graphWidth + 'px; height:' + graphHeight + 'px"></div>';
		if (!graph.graphOpts.noLegend) {
			graphHtmlToAdd += '<div id="legend_' + graphNum + '" class="legendDiv" style="width:' + graph.graphOpts.legendWidth + 'px;"></div>';
		} 

		graphHtmlToAdd += '</div>'
		lastCell.append(graphHtmlToAdd);

		if (graph.graphOpts.noLegend) {
			graph.legendDiv = invisibleDiv;
		} else {
			graph.legendDiv = $("#" + graph.legendDivString).get()[0];
		}

		graph.dyGraphTitle = graph.graphOpts.title
		delete graph.graphOpts.title
		graph.div = $("#" + graph.graphDivString).get()[0];		
		graph.div.graph = graph;
		graph.overlay = $("#graphOverlay_" + graphNum);
		graph.overlayText = $("#graphOverlayText_" + graphNum);

		// Register for common data sources
		for (var dsIndex in graph.dataSources) {
			var ds = graph.dataSources[dsIndex];
			if (typeof ds == "string") {
				if (!graphsByDataSource[ds]) graphsByDataSource[ds] = [];
				graphsByDataSource[ds].push(graph);
			}
		}

		var queryGraph = function(graphToQuery) {
			if (graphToQuery.graphOpts.width == "wholeLine") {
				$(window).resize(function() { resizeGraphByDiv(graphToQuery); });
			}

			var shouldTail = false;;
			for (dsIndex in graphToQuery.dataSources) {
				if (graphToQuery.dataSources[dsIndex].tailSecondsInterval != null) {
					shouldTail = true;
					break;
				}
			}

			if (shouldTail) {
				for (dsIndex in graphToQuery.dataSources) {
					var dsToQuery = graphToQuery.dataSources[dsIndex];
					function queryDataSource(ds) {
						graphToQuery.query = new Query({
							dataSources: [ds],
							tailSecondsInterval: ds.tailSecondsInterval,
							tailCallback: function(data) { 
								plotGraph(data,graphToQuery); 
							},
							callback: function(data) { 
								plotGraph(data,graphToQuery); 
							}
					    });
						graphToQuery.query.queryData();
					}
					queryDataSource(dsToQuery);
				}
			} else {
				graphToQuery.query = new Query({
					dataSources: graphToQuery.dataSources,
					tailCallback: function(data) { 
						plotGraph(data,graphToQuery); 
					},
					callback: function(data) { 
						plotGraph(data,graphToQuery); 
					}
			    });
				graphToQuery.query.queryData();
			}

			//setTimeout(function() {
			//	resizeGraphByDiv(graphToQuery);
			//}, 100);
		}
		queryGraph(graph);
	}

	if (dashboard.dataSources != null && dashboard.dataSources.length > 0)  {
		for (commonDsIndex in dashboard.dataSources) {
			var commonDs = dashboard.dataSources[commonDsIndex];

			function commonDataSourceQuery(ds) {
				commonQuery[ds.id] = new Query({
					dataSources: [ds],
					tailSecondsInterval: ds.tailSecondsInterval,
					tailCallback: function(data) { 
						commonDataSourceQueryOver(data,ds.id); 
					},
					callback: function(data) { 
						commonDataSourceQueryOver(data,ds.id); 
					}
			    });
				commonQuery[ds.id].queryData();
			}

			commonDataSourceQuery(commonDs);
		}
	}
}

function commonDataSourceQueryOver(data, dsId) {
	var regeisteredGraphs = graphsByDataSource[dsId];
	for (dsNum in regeisteredGraphs) {
		
		var dataCopy = [];
		for (i in data) {
			var source = data[i];
			var clone = {};
			for (key in source) {
				clone[key] = source[key];
			}
			dataCopy.push(clone);
		}
		plotGraph(dataCopy,regeisteredGraphs[dsNum]);
	}
}
var graphsByDataSource = {};
var commonQuery = {};

var getWholeLineWidth = function(graphObj) {
	var newTotalWidth = $(window).width() - 300;
	return newTotalWidth - graphObj.graphOpts.legendWidth;
}
function resizeGraphByDiv(graphObj) {
	//graphObj.graphOpts.width= $(graphObj.div.parentNode).width() - 10;
	if (graphObj.graphOpts.width != "wholeLine") return;
	var newGraphWidth = getWholeLineWidth(graphObj);
	
	$(graphObj.div).width(graphObj.graphOpts.width = newGraphWidth);
	$(graphObj.overlay).width(graphObj.graphOpts.width + graphObj.graphOpts.legendWidth);

	if (cacheByDiv && cacheByDiv[graphObj.div.id]) {
		cacheByDiv[graphObj.div.id].dygraph.resize(graphObj.graphOpts.width, graphObj.graphOpts.height || defaultHeight)
	}
}

function deleteDashboardForce(d) {
	$.ajax({
		url: "/deleteDashboard",
		data: "id=" + d.id,
		dataType: "json",
		cache: false,
		success: function(resultObject) {
			if (resultObject.error) {
				showAlert({OK: true, title:"Delete Failed", text:"Server Error: " + resultObject.error});
			} else {
				window.reloadDashboardList();
				window.location.href = "/";
			}
		}
	});
}

function deleteDashboard() {
	showAlert({OK: true, Cancel: true, title:"Confirm Delete", text:"Are you sure you want to delete this dashboard?", callback: 
		function(choice) {
			if (choice == "OK") {
				deleteDashboardForce(dashboard);
			}
		}});
}

function codeDashboard() {
	var win=window.open(window.location.origin + "/designer.html?url=" + queryArgs.url, '_blank');
  	win.focus();
}

var originalDashboardStr = null;
function applyVariablesParse(str) {
	originalDashboardStr = str;
	var obj = JSON.parse(str);

	// Apply variables
	if (obj.variables) {
		var varArr = Object.keys(obj.variables);
		varArr.sort(function(v1,v2) { return v2.length - v1.length});

		for (varIndex in varArr) {
			var variable = varArr[varIndex];
			var value = obj.variables[variable];
			if (typeof value == "object") {
				str = str.replace(new RegExp("\"\\$" + variable + "\"", 'g'), JSON.stringify(value));
			} else {
				str = str.replace(new RegExp("\\$" + variable, 'g'), value);
			}
		}
	}

	// reparse
	try {
		obj = JSON.parse(str);
		for (graphIndex in obj.graphs) {
			obj.graphs[graphIndex].index = Number(graphIndex);
		}

	} catch (ex) {
		console.error("Failed applying variables, they cause invalid JSON: " + ex);
		return;
	}

	return obj;
}

if (queryArgs.url) {
	$.ajax({
		url: queryArgs.url,
		cache: false,
		success: function(result) {
			try {
				dashboard = applyVariablesParse(result);
			} catch (ex) {
				console.error("Dasbhoard json is invalid: " + ex.stack);
			}

			var pageTable = $("#pageTable");
			pageTable.append(
				'<div class="codemirrorTopBar" style=""> \
						<span class="crayonButton" onclick="codeDashboard()"  style="margin-left:30px">Code</span> \
						<span class="crayonButton" onclick="deleteDashboard()"  style="margin-left:10px">Delete Dashboard</span> \
				</div> ');

			try {
				loadDashboard();
			} catch (ex) {
				console.error("Failed loading dashboard:" + ex.stack);
			}				
		}
	});
} else if (queryArgs.dashboard) {

	try {
		dashboard = applyVariablesParse(queryArgs.dashboard);
		if (!dashboard.graphs) {
			var newDashboard = {
				graphs: [dashboard]
			};
		}
		dashboard = newDashboard || dashboard;
	} catch (ex) {
		console.error("Dasbhoard json is invalid: " + ex.stack);
	}

	var pageTable = $("#pageTable");
	pageTable.append(
	'<div class="codemirrorTopBar" style=""> \
			<span class="crayonButton" onclick="codeDashboard()"  style="margin-left:30px">Code</span> \
	</div> ');

	try {
		loadDashboard();
	} catch (ex) {
		console.error("Failed loading dashboard:" + ex.stack);
	}
}

</script>
</html>